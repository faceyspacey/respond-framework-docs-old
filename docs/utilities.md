# Utilities

Respond makes available several common utilities, so you don't have to reinvent the wheel and so userland code sees your app the same way Respond sees it. 

Here's how you get them:

```js
import { 
  isRedirect,
  isNotFound,
  isServer,
  isHydrate,
  isAction,

  toAction,
  toEntries
} from 'respond-framework/utils'
```

## `isRedirect(action): boolean`

Usage in SSR:

```js
export default async configureStore(req, res) {
  // ... 

  const { store, firstRoute } = createModule(config, options)
  const action = await store.dispatch(firstRoute())

  if (isRedirect(action)) {
    const { status, url } = action
    res.redirect(status || 302, url) // short-circuit because request is complete
    return false
  }

  // ...
  return store
}
```

## `isNotFound(action | string): boolean`


```js
isNotFound({ type: 'NOT_FOUND' }) // true
isNotFound({ type: 'namespace/NOT_FOUND' }) // true
isNotFound('namespace/NOT_FOUND') // true

isNotFound({ type: 'NOT_FOUND.complete' }) // false
```



## `isServer(): boolean`

Use this to guarantee userland code sees environment like Respond sees it.



## `isHydrate(request): boolean`

Returns the result of this logic:

```js
const isHydrate = request => {
  const { universal } = request.location
  return universal && !isServer() && request.kind === 'load'
}
```



## `isAction(any): boolean`


Respond sometimes considers an object an actions before it receives a `type`. You can check similar intents like so:

```js
isAction({ params: { foo: 'bar' } })
```


## `toAction(api, entry, state?, key?): action`

To convert any set of data to a *Respond Standard Routing Action*, you can pass what you have to `toAction` in the following ways:

```js
const api = createModule(config, options)

// 1) independent args
toAction(api, '/foo/bar') // perhaps a URL received from a deep link in your React Native app
toAction(api, '/foo/bar', { some: 'state' })
toAction(api, '/foo/bar', { some: 'state' }, 123456)  // path, state, unique key

// 2) array
toAction(api, ['/foo/bar'])
toAction(api, ['/foo/bar', { some: 'state' }])
toAction(api, ['/foo/bar', { some: 'state' }, 123456]) // an array containing all three

// 3) action object
toAction(api, { type: 'FOO', params: { param: 'bar' } }) // an action object

const { store, firstRoute, history, config, options } = api //
// typical next steps: codispatch firstRoute and render your app
```

> `api` contains your config, options, and `history` generated by Respond. The `api` can be received in 3 places: the return of `createModule`, the 4th argument passed to components, or the `request` object passed to callbacks/middleware can be used.

### 2-way conversion

Since *Respond Standard Routing Actions* contain the URL, `toAction` can be used to get the URL of an action as well:

```js
const { url } = toAction({ type: 'FOO', params: { param: 'bar' } })
```

This makes `toAction` useful wherever you need to make both kinds of conversions:

- *action to URL*
- *URL to action*

Examples of places you might use this include custom `<Link />` and `<Route />` components.


## `toEntries(api, entries[], index?, n?)`

```js
// 1) array of path strings 
toEntries(api, ['/foo/bar']) // same as above, but wrapped in an array

// 2) array of arrays
toEntries(api, [['/foo/bar', { some: 'state' }]])
toEntries(api, [['/foo/bar', { some: 'state' }, 123456]])

// 3) action objects
toEntries(api, [{ type: 'FOO', params: { param: 'bar' }}])

// manipulate the index and direction the user is going
toEntries(api, ['/foo/bar', '/login', '/'], 1)      // user is on '/login'
toEntries(api, ['/foo/bar', '/login', '/'], 1, -1)  // user went backword from '/'

// all return:
const { entries, index, n } = toEntries(api, entries)
```

> FYI: under the hood `toEntries` calls `toAction` for each entry.